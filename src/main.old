/***************************************************************************//**
 * @file main.c
 * @brief Program pro obsluhu tří RS232 portů a čtyř LED diod na EFM32GG11B820F2048GQ64
 * @version 2.2
 * @note Upraven pro QFP64 balíček s LED1 na PA8, LED2 na PD5, LED3 na PD6, LED4 na PD8
 * @note Přidány časovače TIMER0 (1 Hz) a TIMER1 (1200 Hz) pro ovládání LED2 a LED3
 * @note Verze s přímou konfigurací registrů (bez em_timer.h)
 ******************************************************************************/

#include "em_device.h"
#include "em_chip.h"
#include "em_cmu.h"
#include "em_gpio.h"
#include "em_usart.h"

// Buffery pro příjem dat
#define BUFFER_SIZE 256
char rxBuffer1[BUFFER_SIZE];
char rxBuffer2[BUFFER_SIZE];
char rxBuffer3[BUFFER_SIZE];
volatile uint16_t rxIndex1 = 0;
volatile uint16_t rxIndex2 = 0;
volatile uint16_t rxIndex3 = 0;

// Definice portu TX
#define TX_PORT   (gpioPortA)
#define TX_PIN    (1)  // PA1

// Definice pro LED diody
#define LED1_PORT          (gpioPortA)
#define LED1_PIN           (8)  // PA8 (Uživatelská LED)

#define LED2_PORT          (gpioPortD)
#define LED2_PIN           (5)  // PD5 (Toggle 1Hz přes TIMER0)

#define LED3_PORT          (gpioPortD)
#define LED3_PIN           (6)  // PD6 (Toggle 1200Hz přes TIMER1)

#define LED4_PORT          (gpioPortD)
#define LED4_PIN           (8)  // PD8 (Volitelné použití)

/***************************************************************************//**
 * @brief Inicializace všech LED diod
 ******************************************************************************/
void initLEDs(void)
{
    // Povolení hodin pro GPIO (pokud ještě není)
    CMU_ClockEnable(cmuClock_GPIO, true);

    // Konfigurace LED1 - PA8 jako výstup, výchozí stav LOW (LED zhasnuta)
    GPIO_PinModeSet(LED1_PORT, LED1_PIN, gpioModePushPull, 0);

    // Konfigurace LED2 - PD5 jako výstup, výchozí stav LOW
    GPIO_PinModeSet(LED2_PORT, LED2_PIN, gpioModePushPull, 0);

    // Konfigurace LED3 - PD6 jako výstup, výchozí stav LOW
    GPIO_PinModeSet(LED3_PORT, LED3_PIN, gpioModePushPull, 0);

    // Konfigurace LED4 - PD8 jako výstup, výchozí stav LOW
    GPIO_PinModeSet(LED4_PORT, LED4_PIN, gpioModePushPull, 0);
}

/***************************************************************************//**
 * @brief Rozsvícení LED1
 ******************************************************************************/
void LED1_On(void)
{
    GPIO_PinOutSet(LED1_PORT, LED1_PIN);
}

/***************************************************************************//**
 * @brief Zhasnutí LED1
 ******************************************************************************/
void LED1_Off(void)
{
    GPIO_PinOutClear(LED1_PORT, LED1_PIN);
}

/***************************************************************************//**
 * @brief Přepnutí stavu LED1
 ******************************************************************************/
void LED1_Toggle(void)
{
    GPIO_PinOutToggle(LED1_PORT, LED1_PIN);
}

/***************************************************************************//**
 * @brief Přepnutí stavu LED2
 ******************************************************************************/
void LED2_Toggle(void)
{
    GPIO_PinOutToggle(LED2_PORT, LED2_PIN);
}

/***************************************************************************//**
 * @brief Přepnutí stavu LED3
 ******************************************************************************/
void LED3_Toggle(void)
{
    GPIO_PinOutToggle(LED3_PORT, LED3_PIN);
}

/***************************************************************************//**
 * @brief Přepnutí stavu LED4
 ******************************************************************************/
void LED4_Toggle(void)
{
    GPIO_PinOutToggle(LED4_PORT, LED4_PIN);
}

/***************************************************************************//**
 * @brief Inicializace TIMER0 pro generování přerušení 1Hz (jednou za vteřinu)
 * @note Používá se pro toggle LED2
 ******************************************************************************/
void initTIMER0(void)
{
    // Povolení hodin pro TIMER0
    CMU_ClockEnable(cmuClock_TIMER0, true);

    // Reset časovače
    TIMER0->CTRL = 0;
    TIMER0->CNT = 0;

    // Výpočet TOP hodnoty pro 1 Hz
    // Předpokládáme HFPERCLK = 48 MHz
    // S předděličkou 1024: 48 MHz / 1024 = 46875 Hz
    // Pro 1 Hz: 46875 / 1 = 46875
    // Pokud je hodiny 38.4 MHz: 38400000 / 1024 / 1 = 37500
    uint32_t topValue = 46875 - 1;  // TOP = (freq / prescaler / desired_freq) - 1

    // Nastavení TOP hodnoty
    TIMER0->TOP = topValue;

    // Konfigurace CTRL registru
    // PRESC = 1024 (hodnota 10 v bitu PRESC), MODE = Up counting
    TIMER0->CTRL = (10 << _TIMER_CTRL_PRESC_SHIFT) | TIMER_CTRL_MODE_UP;

    // Vymazání všech příznaků přerušení
    TIMER0->IFC = _TIMER_IFC_MASK;

    // Povolení přerušení overflow
    TIMER0->IEN = TIMER_IEN_OF;

    // Povolení přerušení v NVIC
    NVIC_ClearPendingIRQ(TIMER0_IRQn);
    NVIC_EnableIRQ(TIMER0_IRQn);

    // Spuštění časovače
    TIMER0->CMD = TIMER_CMD_START;
}

/***************************************************************************//**
 * @brief Inicializace TIMER1 pro generování přerušení 1200Hz
 * @note Používá se pro toggle LED3 (600 Hz blikání - toggle 1200x/s)
 ******************************************************************************/
void initTIMER1(void)
{
    // Povolení hodin pro TIMER1
    CMU_ClockEnable(cmuClock_TIMER1, true);

    // Reset časovače
    TIMER1->CTRL = 0;
    TIMER1->CNT = 0;

    // Výpočet TOP hodnoty pro 1200 Hz
    // S předděličkou 16: 48 MHz / 16 = 3 MHz
    // Pro 1200 Hz: 3000000 / 1200 = 2500
    // Pokud je hodiny 38.4 MHz: 38400000 / 16 / 1200 = 2000
    uint32_t topValue = 2500 - 1;  // TOP = (freq / prescaler / desired_freq) - 1

    // Nastavení TOP hodnoty
    TIMER1->TOP = topValue;

    // Konfigurace CTRL registru
    // PRESC = 16 (hodnota 4 v bitu PRESC), MODE = Up counting
    TIMER1->CTRL = (4 << _TIMER_CTRL_PRESC_SHIFT) | TIMER_CTRL_MODE_UP;

    // Vymazání všech příznaků přerušení
    TIMER1->IFC = _TIMER_IFC_MASK;

    // Povolení přerušení overflow
    TIMER1->IEN = TIMER_IEN_OF;

    // Povolení přerušení v NVIC
    NVIC_ClearPendingIRQ(TIMER1_IRQn);
    NVIC_EnableIRQ(TIMER1_IRQn);

    // Spuštění časovače
    TIMER1->CMD = TIMER_CMD_START;
}

/***************************************************************************//**
 * @brief Obsluha přerušení TIMER0 - 1Hz
 ******************************************************************************/
void TIMER0_IRQHandler(void)
{
    // Vymazání příznaku přerušení overflow
    TIMER0->IFC = TIMER_IFC_OF;

    // Toggle LED2
    LED2_Toggle();
}

/***************************************************************************//**
 * @brief Obsluha přerušení TIMER1 - 1200Hz
 ******************************************************************************/
void TIMER1_IRQHandler(void)
{
    // Vymazání příznaku přerušení overflow
    TIMER1->IFC = TIMER_IFC_OF;

    GPIO_PinOutToggle(TX_PORT, TX_PIN);

    // Toggle LED3
    LED3_Toggle();
}

/***************************************************************************//**
 * @brief Inicializace USART0 - první UART (115200, 8N1)
 * @note Pro QFN64: Použita LOCATION 0 (PE10/PE11)
 ******************************************************************************/
void initUSART0(void)
{
    // Povolení hodin pro USART0 a GPIO
    CMU_ClockEnable(cmuClock_USART0, true);
    CMU_ClockEnable(cmuClock_GPIO, true);

    // Konfigurace GPIO pinů pro USART0 LOCATION 0
    // TX - PE10
    GPIO_PinModeSet(gpioPortE, 10, gpioModePushPull, 1);
    // RX - PE11
    GPIO_PinModeSet(gpioPortE, 11, gpioModeInput, 0);

    // Konfigurace USART0
    USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;
    init.baudrate = 115200;
    init.databits = usartDatabits8;
    init.parity = usartNoParity;
    init.stopbits = usartStopbits1;

    USART_InitAsync(USART0, &init);

    // Nastavení lokace pinů (LOCATION 0)
    USART0->ROUTEPEN = USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;
    USART0->ROUTELOC0 = (USART0->ROUTELOC0 & ~(_USART_ROUTELOC0_TXLOC_MASK |
                                                _USART_ROUTELOC0_RXLOC_MASK)) |
                        (0 << _USART_ROUTELOC0_TXLOC_SHIFT) |
                        (0 << _USART_ROUTELOC0_RXLOC_SHIFT);

    // Povolení přerušení pro příjem
    USART_IntClear(USART0, _USART_IF_MASK);
    USART_IntEnable(USART0, USART_IEN_RXDATAV);
    NVIC_ClearPendingIRQ(USART0_RX_IRQn);
    NVIC_EnableIRQ(USART0_RX_IRQn);
}

/***************************************************************************//**
 * @brief Inicializace UART0 - druhý UART (9600, 8N1)
 * @note Pro QFN64: Použita LOCATION 4 (PC4/PC5)
 ******************************************************************************/
void initUART0(void)
{
    // Povolení hodin pro UART0
    CMU_ClockEnable(cmuClock_UART0, true);

    // Konfigurace GPIO pinů pro UART0 LOCATION 4
    // TX - PC4
    GPIO_PinModeSet(gpioPortC, 4, gpioModePushPull, 1);
    // RX - PC5
    GPIO_PinModeSet(gpioPortC, 5, gpioModeInput, 0);

    // Konfigurace UART0
    USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;
    init.baudrate = 9600;
    init.databits = usartDatabits8;
    init.parity = usartNoParity;
    init.stopbits = usartStopbits1;

    USART_InitAsync(UART0, &init);

    // Nastavení lokace pinů (LOCATION 4)
    UART0->ROUTEPEN = USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;
    UART0->ROUTELOC0 = (UART0->ROUTELOC0 & ~(_USART_ROUTELOC0_TXLOC_MASK |
                                              _USART_ROUTELOC0_RXLOC_MASK)) |
                       (4 << _USART_ROUTELOC0_TXLOC_SHIFT) |
                       (4 << _USART_ROUTELOC0_RXLOC_SHIFT);

    // Povolení přerušení pro příjem
    USART_IntClear(UART0, _USART_IF_MASK);
    USART_IntEnable(UART0, USART_IEN_RXDATAV);
    NVIC_ClearPendingIRQ(UART0_RX_IRQn);
    NVIC_EnableIRQ(UART0_RX_IRQn);
}

/***************************************************************************//**
 * @brief Inicializace UART1 - třetí UART (115200, 8N1)
 * @note Pro QFN64: Použita LOCATION 4 (PE12/PE13)
 ******************************************************************************/
void initUART1(void)
{
    // Povolení hodin pro UART1
    CMU_ClockEnable(cmuClock_UART1, true);

    // Konfigurace GPIO pinů pro UART1 LOCATION 4
    // TX - PE12
    GPIO_PinModeSet(gpioPortE, 12, gpioModePushPull, 1);
    // RX - PE13
    GPIO_PinModeSet(gpioPortE, 13, gpioModeInput, 0);

    // Konfigurace UART1
    USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;
    init.baudrate = 115200;
    init.databits = usartDatabits8;
    init.parity = usartNoParity;
    init.stopbits = usartStopbits1;

    USART_InitAsync(UART1, &init);

    // Nastavení lokace pinů (LOCATION 4)
    UART1->ROUTEPEN = USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;
    UART1->ROUTELOC0 = (UART1->ROUTELOC0 & ~(_USART_ROUTELOC0_TXLOC_MASK |
                                              _USART_ROUTELOC0_RXLOC_MASK)) |
                       (4 << _USART_ROUTELOC0_TXLOC_SHIFT) |
                       (4 << _USART_ROUTELOC0_RXLOC_SHIFT);

    // Povolení přerušení pro příjem
    USART_IntClear(UART1, _USART_IF_MASK);
    USART_IntEnable(UART1, USART_IEN_RXDATAV);
    NVIC_ClearPendingIRQ(UART1_RX_IRQn);
    NVIC_EnableIRQ(UART1_RX_IRQn);
}

/***************************************************************************//**
 * @brief Odeslání řetězce přes USART0
 ******************************************************************************/
void sendStringUSART0(const char *str)
{
    while (*str) {
        USART_Tx(USART0, *str++);
    }
}

/***************************************************************************//**
 * @brief Odeslání řetězce přes UART0
 ******************************************************************************/
void sendStringUART0(const char *str)
{
    while (*str) {
        USART_Tx(UART0, *str++);
    }
}

/***************************************************************************//**
 * @brief Odeslání řetězce přes UART1
 ******************************************************************************/
void sendStringUART1(const char *str)
{
    while (*str) {
        USART_Tx(UART1, *str++);
    }
}

/***************************************************************************//**
 * @brief Obsluha přerušení USART0 RX
 ******************************************************************************/
void USART0_RX_IRQHandler(void)
{
    uint8_t data = USART_Rx(USART0);

    if (data == 13) { // CR
        rxBuffer1[rxIndex1] = '\0';
        sendStringUSART0(rxBuffer1);
        sendStringUSART0("\r\n");
        rxIndex1 = 0;
    } else {
        if (rxIndex1 < BUFFER_SIZE - 1) {
            rxBuffer1[rxIndex1++] = data;
        }
    }
}

/***************************************************************************//**
 * @brief Obsluha přerušení UART0 RX
 ******************************************************************************/
void UART0_RX_IRQHandler(void)
{
    uint8_t data = USART_Rx(UART0);

    if (data == 13) { // CR
        rxBuffer2[rxIndex2] = '\0';
        sendStringUART0(rxBuffer2);
        sendStringUART0("\r\n");
        rxIndex2 = 0;
    } else {
        if (rxIndex2 < BUFFER_SIZE - 1) {
            rxBuffer2[rxIndex2++] = data;
        }
    }
}

/***************************************************************************//**
 * @brief Obsluha přerušení UART1 RX
 ******************************************************************************/
void UART1_RX_IRQHandler(void)
{
    uint8_t data = USART_Rx(UART1);

    if (data == 13) { // CR
        rxBuffer3[rxIndex3] = '\0';
        sendStringUART1(rxBuffer3);
        sendStringUART1("\r\n");
        rxIndex3 = 0;
    } else {
        if (rxIndex3 < BUFFER_SIZE - 1) {
            rxBuffer3[rxIndex3++] = data;
        }
    }
}

/**************************************************************************//**
 * @brief Jednoduchá blokující funkce pro zpoždění
 *****************************************************************************/
void delay_ms(uint32_t ms)
{
    uint32_t cycles_per_ms = 1360; // Nastaveno osciloscopem

    volatile uint32_t i;
    uint32_t total_cycles = cycles_per_ms * ms;

    for (i = 0; i < total_cycles; i++)
    {
        i = i;
    }
}

/***************************************************************************//**
 * @brief Hlavní funkce
 ******************************************************************************/
int main(void)
{
    // Inicializace čipu
    CHIP_Init();

    // Konfigurace GPIO pro PB9
    GPIO_PinModeSet(TX_PORT, TX_PIN, gpioModePushPull, 0);

    // Inicializace všech LED diod
    initLEDs();

    // Inicializace všech tří UART portů
    initUSART0();
    initUART0();
    initUART1();

    // Inicializace časovačů
    initTIMER0();  // 1 Hz pro LED2
    initTIMER1();  // 1200 Hz pro LED3

    // Krátké zpoždění pro stabilizaci
    for (volatile int i = 0; i < 100000; i++);

    // Odeslání hlaviček
    sendStringUART0 ("TCI COM1-A (UART0) - QFN64\r\n");
    sendStringUART1 ("TCI COM2-B (UART1) - QFN64 DEBUG1\r\n");
    sendStringUSART0("TCI COM3-C (USART0) - QFN64\r\n");

    sendStringUART1 ("LED2 blikani 1Hz (TIMER0)\r\n");
    sendStringUART1 ("LED3 blikani 600Hz (TIMER1 @ 1200Hz toggle)\r\n");

    // Hlavní smyčka - LED1 a LED4 řízení v hlavní smyčce
    // LED2 a LED3 jsou ovládány přerušeními z časovačů
    while (1) {
        // Blikání LED1 s intervalem 200ms
        LED1_On();
        LED4_Toggle();
        delay_ms(200);
        sendStringUART1 ("*");

        LED1_Off();
        LED4_Toggle();
        delay_ms(200);
        sendStringUART1 ("-");

        // LED2 bliká automaticky 1Hz přes TIMER0
        // LED3 bliká automaticky 600Hz přes TIMER1 (toggle 1200x/s)
        // LED4 lze využít dle potřeby
    }
}
